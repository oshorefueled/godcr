// +build ignore

package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"image"
	"image/png"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"runtime"
	"strings"
)
// source is the directory of the icon files usually in PNG format.
const source = "/ui/assets/decredicons/"

// destination is the directory where the byte encoded file will be written.
const destination = "decredmaterial"

// pkgName is the package name of the byte encoded file.
const pkgName = "decredmaterial"

// filename is the file name of the byte encoded file.
const fileName = "decredicons.go"

// destination path is the entire path of the byte encoded file.
const destinationPath = "/ui/" + destination + "/" + fileName

// suffix is added to the name of the source file and used as a variable in the byte encoded file.
const suffix = "Icon"

var out = new(bytes.Buffer)
var basePath = ""

func main() {
	err := generateIcons()
	if err != nil {
		fmt.Printf("%v \n", err)
	}
}

func generateIcons() error {
	_, b, _, _ := runtime.Caller(0)
	d := path.Join(path.Dir(b))
	basePath = filepath.Dir(d)
	f, err := os.OpenFile(basePath+destinationPath, os.O_RDONLY|os.O_CREATE, 0666)
	if err != nil {
		return err
	}
	defer f.Close()

	fileNames, err := iconFileNames()
	if err != nil {
		return err
	}

	icons, err := newIcons(fileNames)
	if err != nil {
		return err
	}

	stat, err := f.Stat()
	if err != nil {
		return err
	}

	if stat.Size() == 0 {
		out.WriteString("// generated by go run gen.go; DO NOT EDIT\n\npackage ")
		out.WriteString(pkgName)
		out.WriteString("\n\n")
	} else {
		scanner := bufio.NewScanner(f)
		for scanner.Scan() {
			fmt.Fprintf(out, "%s \n", scanner.Text())
		}
	}

	err = writeIcons(icons)
	if err != nil {
		return err
	}

	return nil
}

// f2v changes a file name to a variable name used in the icon file.
func f2v(fileName string) string {
	slice := strings.Split(fileName, ".")
	return strings.Title(slice[0]) + suffix
}

// writeIcons writes the byte equivalent of decred icons to the icon file.
func writeIcons(icons []string) error {
	for _, v := range icons {
		n := f2v(v)
		fmt.Fprintf(out, "var %s = []byte{", n)
		data, err := readIcon(v)
		if err != nil {
			fmt.Printf("readIconError: %v\n", err)
			continue
		}
		for i, x := range data {
			if i&0x0f == 0x00 {
				out.WriteByte('\n')
			}
			fmt.Fprintf(out, "%#02x, ", x)
		}
		fmt.Fprintf(out, "\n}\n\n")
	}

	raw := out.Bytes()
	formatted, err := format.Source(raw)
	if err != nil {
		fmt.Printf("ERROR: %v", err)
	}
	if err := ioutil.WriteFile(filepath.Join(destination, fileName), formatted, 0666); err != nil {
		fmt.Printf("ERROR: %v", err)
	}
	return nil
}

// checkWordInLine checks each line in the icon byte file if an icon in the source directory has already been
// converted to bytes
func checkWordInLine(line string, words []string) (contains bool, index int) {
	for k, v := range words {
		if strings.Contains(line, f2v(v)) {
			return true, k
		}
	}
	return false, -1
}

// iconFileNames reads the list of icons in the source directory and returns the list as a slice.
func iconFileNames() (iconFileNames []string, err error) {
	f, err := os.Open(basePath + source)
	if err != nil {
		return
	}
	defer f.Close()

	infos, err := f.Readdir(-1)
	if err != nil {
		return
	}

	for _, info := range infos {
		// skip the empty .icons file in source the directory
		if info.Size() == 0 {
			continue
		}
		iconFileNames = append(iconFileNames, info.Name())
	}

	return
}

// newIcons check which icon in the source directory hasn't been converted to a byte format. It returns the list of
// new source files or all source files if all of them are new.
func newIcons(iconFileNames []string) (newIconsList []string, err error) {
	var existing []string
	iconFile, err := os.Open(basePath + destinationPath)
	if err != nil {
		return
	}
	defer iconFile.Close()
	scanner := bufio.NewScanner(iconFile)
	for scanner.Scan() {
		if found, index := checkWordInLine(scanner.Text(), iconFileNames); found {
			existing = append(existing, iconFileNames[index])
		}
	}
	newIconsList = diff(iconFileNames, existing)

	return
}

// readIcon reads a source icon, decodes it and encodes it as bytes
func readIcon(icon string) ([]byte, error) {
	f, err := os.Open(basePath + source + icon)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	buf := new(bytes.Buffer)
	img, _, err := image.Decode(f)
	if err != nil {
		return nil, err
	}

	err = png.Encode(buf, img)
	if err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

// diff returns the difference between two slices. It returns the combination of both slices if there's no difference.
func diff(a, b []string) []string {
	temp := map[string]int{}
	for _, s := range a {
		temp[s]++
	}
	for _, s := range b {
		temp[s]--
	}

	var result []string
	for s, v := range temp {
		if v != 0 {
			result = append(result, s)
		}
	}
	return result
}
