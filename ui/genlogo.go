// //  +build ignore

package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"image"
	"image/png"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"runtime"
	"strings"
)

const source = "/ui/assets/decredicons/"
const destination = "decredmaterial"
const pkgName = "decredmaterial"
const filename = "decredicons.go"
const suffix = "Icon"

var out = new(bytes.Buffer)

func main() {
	err := write()
	if err != nil {
		fmt.Printf("%v \n", err)
	}
}

func write() error {
	_, b, _, _ := runtime.Caller(0)
	d := path.Join(path.Dir(b))
	f, err := os.OpenFile(filepath.Dir(d) + "/ui/" + destination + "/" + filename, os.O_RDONLY|os.O_CREATE, 0666)
	if err != nil {
		return err
	}

	defer f.Close()

	fileNames, err := iconFileNames()
	if err != nil {
		return err
	}

	icons, err := newIcons(fileNames)
	if err != nil {
		return err
	}

	stat, err := f.Stat()
	if err != nil {
		return err
	}

	if stat.Size() ==  0 {
		out.WriteString("// generated by go run gen.go; DO NOT EDIT\n\npackage ")
		out.WriteString(pkgName)
		out.WriteString("\n\n")
	} else {
		scanner := bufio.NewScanner(f)
		for scanner.Scan() {
			fmt.Fprintf(out, "%s \n", scanner.Text())
		}
	}

	err = writeIcons(icons)
	if err != nil {
		return err
	}

	return nil
}

func f2v (fileName string) string {
	slice := strings.Split(fileName, ".")
	return strings.Title(slice[0]) + suffix
}

func writeIcons(icons []string) error {
	for _, v := range icons {
		n := f2v(v)
		fmt.Fprintf(out, "var %s = []byte{", n)
		data, err := readIcon(v)
		if err != nil {
			fmt.Printf("readIconError: %v\n", err)
			continue
		}
		for i, x := range data {
			if i&0x0f == 0x00 {
				out.WriteByte('\n')
			}
			fmt.Fprintf(out, "%#02x, ", x)
		}
		fmt.Fprintf(out, "\n}\n\n")
	}

	raw := out.Bytes()
	formatted, err := format.Source(raw)
	if err != nil {
		fmt.Printf("ERROR: %v", err)
	}
	if err := ioutil.WriteFile(filepath.Join(destination, filename), formatted, 0666); err != nil {
		fmt.Printf("ERROR: %v", err)
	}
	return nil
}

func checkWordInLine(line string, words []string) (contains bool, index int) {
	for k, v := range words {
		if strings.Contains(line, f2v(v)) {
			return true, k
		}
	}
	return false, -1
}

func iconFileNames() (iconFileNames []string, err error) {
	_, b, _, _ := runtime.Caller(0)
	d := path.Join(path.Dir(b))
	f, err := os.Open(filepath.Dir(d) + source)
	if err != nil {
		return
	}
	defer f.Close()

	infos, err := f.Readdir(-1)
	if err != nil {
		return
	}

	for _, info := range infos {
		iconFileNames = append(iconFileNames, info.Name())
	}

	return
}

func newIcons(iconFileNames []string) (newIconsList []string, err error) {
	var existing []string
	_, b, _, _ := runtime.Caller(0)
	d := path.Join(path.Dir(b))
	iconFile, err := os.Open(filepath.Dir(d) + "/ui/" + destination + "/" + filename)
	if err != nil {
		return
	}
	defer iconFile.Close()
	scanner := bufio.NewScanner(iconFile)
	for scanner.Scan() {
		if found, index := checkWordInLine(scanner.Text(), iconFileNames); found {
			existing = append(existing, iconFileNames[index])
		}
	}
	newIconsList = diff(iconFileNames, existing)

	return
}

func readIcon(icon string) ([]byte, error) {
	_, b, _, _ := runtime.Caller(0)
	d := path.Join(path.Dir(b))
	f, err := os.Open(filepath.Dir(d) + source + icon)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	buf := new(bytes.Buffer)
	img, _, err := image.Decode(f)
	if err != nil {
		return nil, err
	}

	err = png.Encode(buf, img)
	if err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

func diff(a, b []string) []string {
	temp := map[string]int{}
	for _, s := range a {
		temp[s]++
	}
	for _, s := range b {
		temp[s]--
	}

	var result []string
	for s, v := range temp {
		if v != 0 {
			result = append(result, s)
		}
	}
	return result
}
